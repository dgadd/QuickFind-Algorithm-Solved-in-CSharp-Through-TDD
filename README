QUICK FIND ALGORITHM SOLVED IN C# THROUGH TDD (Test-Driven-Development)
=======================================================================

2010Jul02  David Gadd
This project demonstrates with 4 TDD unit tests and 5 refactorings of ConnectMethod() 
how to build the quick find algorithm demonstrated in Figure 1.3 of Chapter 1 of 
Algorithms in Java by Robert Sedgewick.

In "Algorithms in Java", by Robert Sedgewick, available on Amazon.com here:
http://www.amazon.com/Bundle-Algorithms-Java-Third-Parts/dp/0201775786/
chapter 1 explores a connectivity algorithm in increasingly complex iterations.

The goal of the connectivity is as follows:
a) be able to add pairs of connections as integers (2-3, 5-1, 8-7). 
b) The connections are transitive, so adding 2-3, 3-5, and 5-7 menas that 2-7 is also connected.
c) Once a transitive connection exists, adding the direct connection (2-7) is redundant and therefore ignored.

MY goal in working through these algorithsm is to using Test-Driven Development to solve and evolve them.

Starting from this initial description, I created a series of tests against a utility class that added pairs,
but checked each time before adding to see whether a transitive connection could be established.

In reading further, I found that Sedgewick points out this is the typical first approach, but that it has
signifigant problems:

"First, the number of pairs might be sufficiently large to preclude our saving them all in memory 
in practical applications. Second, and more to the point, no simple method immediately suggests itself 
for determining whether two objects are connected from the set of all the connections, even if we could 
save them all!"

(The book is excellent and I recommend reading it directly to get the full account.)

From here, Sedgewick works through a series of iterative solutions. This dovetails nicely with the principle
in TDD of "start by building the simplest thing that could possibly work". For example, in the TDD Calculator 
kata, this might mean returning 0 (hard-coded) when an empty string is passed.

In this connectivity algorithm, the Quick find approach is the simplest thing that could possibly work:
For each pair you add (eg. 4-9) overwrite the value on one side to be the same value as the other side.
For example, if you started with an array like this:
new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

By the time you were done (all connections established) the array would look like this:
new int[] { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };

or whatever number happened to be the last connection established.

Does this solve every connectivity issue? No. But neither does returning 0 in Calculator kata; it is simply the
first, simplest thing that works.

Having read Sedgewick's explanation for Quick Find, I decided to start by building this algorithm as a series
of unit tests. Read through the unit tests in order, they document the progression through variations until all
Quick Find connectivity add requirements are satisfied.

In the QuickFinder class itself, I would normally refactor without preserving previous iterations. However, for
clarity and ability to trace the steps that got us here, I have kept, but commented out, the previous iterations.
To see how the tests failed across versions, simply switch which iteration is uncommented.

As I proceed further into Ch.1 of Sedgewick, further algorithms will be introduced. Time-permitting, my goal is
to created these using TDD as well, and post them here to github.